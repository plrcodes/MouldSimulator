<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mould</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(20, minmax(0, 1fr));
            grid-template-rows: repeat(20, minmax(0, 1fr));
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .cell {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            cursor: pointer;
        }
        .alive {
            animation: pulse-alive 1s infinite;
        }
        @keyframes pulse-alive {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .oldest-cell {
            box-shadow: 0 0 0 2px #fcd34d; /* Yellow highlight */
        }
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1.5rem;
            justify-content: center;
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #dashboard {
            background-color: #2d3748;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-top: 2rem;
            width: 100%;
            max-width: 600px;
            display: none; /* Hidden by default */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .bar-chart-container {
            position: relative;
            display: flex;
            align-items: flex-end;
            gap: 0.25rem;
            height: 150px;
            width: 100%;
            border-bottom: 2px solid #4a5568;
            padding-top: 1rem;
        }
        .bar-chart-col {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            position: relative;
            height: 100%;
        }
        .bar-chart-bar {
            width: 100%;
            background-color: #4c51bf;
            transition: height 0.3s ease-in-out;
            border-radius: 0.25rem 0.25rem 0 0;
            display: flex;
            flex-direction: column-reverse;
            position: relative;
        }
        .bar-chart-value {
            font-size: 0.75rem;
            position: absolute;
            top: -1.25rem;
            color: #cbd5e0;
        }
        .bar-chart-label {
            font-size: 0.75rem;
            margin-top: 0.5rem;
            color: #a0aec0;
            text-align: center;
        }
        #helpModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #helpContent {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 0.5rem;
            max-width: 800px;
            overflow-y: auto;
            max-height: 90vh;
        }
        #closeHelp {
            float: right;
            cursor: pointer;
            font-size: 1.5rem;
        }
    </style>
</head>
<body>

    <div class="text-center mb-6">
        <h1 class="text-3xl font-bold">Mould</h1>
        <p class="text-gray-400 mt-2">A simulation of growing and dying mould cells.</p>
    </div>

    <div id="grid-container" class="grid-container"></div>

    <div class="control-panel">
        <button id="startButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
            Start
        </button>
        <button id="resetButton" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">
            Reset
        </button>
        <button id="bleachButton" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-50">
            Bleach Splash
        </button>
        <button id="droughtButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-opacity-50">
            Drought
        </button>
        <button id="screenshotButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-50">
            Screenshot
        </button>
        <button id="helpButton" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">?</button>
    </div>

    <div class="mt-4 text-sm text-gray-400">
        Generation: <span id="generationCount">0</span>
    </div>

    <div id="dashboard" class="mt-4">
        <h3 id="dashboardTitle" class="text-xl font-bold text-center mb-4">Simulation Stats: Generation 0</h3>

        <!-- Occupancy Meter -->
        <div class="mb-6">
            <h4 class="text-lg font-semibold mb-2">Occupied Cells</h4>
            <div class="relative w-full h-8 bg-gray-600 rounded-full overflow-hidden">
                <div id="occupiedBar" class="h-full transition-all duration-300 ease-in-out" style="width: 0%;"></div>
                <span id="occupiedPercentage" class="absolute inset-0 flex items-center justify-center text-sm font-bold text-gray-900">0%</span>
            </div>
            <div class="mt-4">
                <canvas id="occupiedSparkline" class="w-full" height="50"></canvas>
            </div>
        </div>

        <!-- Bar Chart -->
        <div>
            <h4 class="text-lg font-semibold mb-2">Population Dynamics</h4>
            <div id="barChartContainer" class="bar-chart-container">
                <!-- Bars will be populated by JavaScript -->
            </div>
        </div>

        <!-- Additional Stats -->
        <div id="additionalStats" class="mt-6 text-sm text-gray-400">
            <ul class="space-y-2">
                <li>
                    <span class="font-semibold">Average Age:</span> 
                    <span id="averageAge">0</span>
                </li>
                <li>
                    <span class="font-semibold">Oldest Cell Age:</span> 
                    <span id="oldestAge">0</span>
                </li>
                <li>
                    <span class="font-semibold">Growth Rate:</span> 
                    <span id="growthRate">0 cells</span>
                </li>
            </ul>
        </div>
    </div>

    <div class="mt-8 flex flex-col items-center">
        <h4 class="text-lg font-semibold mb-4 text-center">Chance of growth per step</h4>
        <div class="flex flex-wrap justify-center gap-4 max-w-2xl">
            <div class="slider-group">
                <label for="slider0">0 Neighbors</label>
                <input type="range" id="slider0" min="0" max="100" value="25" class="w-32">
                <span id="value0">25%</span>
            </div>
            <div class="slider-group">
                <label for="slider1-3">1-3 Neighbors</label>
                <input type="range" id="slider1-3" min="0" max="100" value="50" class="w-32">
                <span id="value1-3">50%</span>
            </div>
            <div class="slider-group">
                <label for="slider4-5">4-5 Neighbors</label>
                <input type="range" id="slider4-5" min="0" max="100" value="25" class="w-32">
                <span id="value4-5">25%</span>
            </div>
            <div class="slider-group">
                <label for="slider6-7">6-7 Neighbors</label>
                <input type="range" id="slider6-7" min="0" max="100" value="5" class="w-32">
                <span id="value6-7">5%</span>
            </div>
        </div>
    </div>
    
    <div id="helpModal">
        <div id="helpContent">
            <span id="closeHelp">&times;</span>
            <h3>Mould Simulation Rules</h3>

            <p>This is a simulation of mould growth on a a $20 \times 20$ grid. At each generation, cells can grow, age, and die based on a set of probabilistic rules.</p>

            <h4>Mould Life Cycle</h4>

            <ul>
                <li>A new cell starts out **white**.</li>

                <li>It gradually turns **gray** over the first 10 generations.</li>

                <li>After 10 generations, it begins to turn **red** as it ages.</li>

                <li>Once a cell is over 10 generations old, its chance of dying in any given turn starts at 20% and increases by 5% each generation, capping at a maximum of 90%.</li>

                <li>The oldest cell on the grid is always highlighted with a **yellow box**.</li>
            </ul>

            <h4>Growth Conditions</h4>

            <p>The chance of a new mould cell spawning in an adjacent empty spot is determined by the number of live neighbors it has, as controlled by the sliders, and based on how ‘crowded’ it is - i.e. how many of the surrounding cells are already occupied. These sliders take effect as soon as you change them i.e. you can alter them during a run and see the results in real time.</p>

            <h4>Disasters</h4>

            <p>You can trigger global events that drastically alter the conditions for a set duration.</p>

            <ul>
                <li>**Bleach Splash:** This is a localized attack. Click this button, then click on the grid to apply bleach. The bleach's effect is strongest at the center and fades with distance and over time. Cells in the bleached area have a chance of dying.</li>

                <li>**Drought:** This is a global, 50-generation disaster. Empty cells turn brown, and the growth rate for all mould with 0-5 neighbors drops to 0%. However, mould in dense clusters with 6-7 neighbors gets a guaranteed 20% chance to grow, allowing them to survive and colonize.</li>
            </ul>

            <h4>Stats Dashboard</h4>

            <p>This dashboard provides a visual summary of the simulation's state when you press **Pause**.</p>

            <ul>
                <li>**Occupied Cells:** Shows the percentage of the grid covered by mould. The **horizontal bar** changes color based on density (green for low, yellow for medium, red for high), and the graph below it shows the population percentage over time.</li>

                <li>**Population Dynamics:** This bar chart provides a breakdown of the population's changes in the last generation. The bars show the number of **new cells spawned** and **cells that died**, as well as the age distribution of the mould population, divided into five equal groups (quintiles).</li>

                <li>**Average Age:** The average age of all living mould cells.</li>

                <li>**Oldest Cell Age:** The age of the single oldest cell in the simulation.</li>

                <li>**Growth Rate:** The net change in the number of mould cells since the last generation (spawns minus deaths).</li>
            </ul>
            <br>
            <p>Coded with Gemini 2.5 by Peter le Roux 2025</p>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const GRID_SIZE = 20;
            const BLEACH_INITIAL_VALUE = 95;
            const BLEACH_DECAY_RATE = 20;
            const BLEACH_FADE_RATE = 4;
            const DROUGHT_DURATION = 50;
            const DROUGHT_LOW_GROWTH = 0;
            const DROUGHT_HIGH_GROWTH = 20;

            const gridContainer = document.getElementById('grid-container');
            const startButton = document.getElementById('startButton');
            const resetButton = document.getElementById('resetButton');
            const bleachButton = document.getElementById('bleachButton');
            const droughtButton = document.getElementById('droughtButton');
            const screenshotButton = document.getElementById('screenshotButton');
            const helpButton = document.getElementById('helpButton');
            const generationCountSpan = document.getElementById('generationCount');
            const dashboard = document.getElementById('dashboard');

            // Dashboard elements
            const occupiedBar = document.getElementById('occupiedBar');
            const occupiedPercentageSpan = document.getElementById('occupiedPercentage');
            const barChartContainer = document.getElementById('barChartContainer');
            const averageAgeSpan = document.getElementById('averageAge');
            const oldestAgeSpan = document.getElementById('oldestAge');
            const growthRateSpan = document.getElementById('growthRate');
            const occupiedSparklineCanvas = document.getElementById('occupiedSparkline');
            const sparklineCtx = occupiedSparklineCanvas.getContext('2d');
            const helpModal = document.getElementById('helpModal');
            const closeModal = document.getElementById('closeHelp');

            // Slider elements
            const slider0 = document.getElementById('slider0');
            const value0 = document.getElementById('value0');
            const slider13 = document.getElementById('slider1-3');
            const value13 = document.getElementById('value1-3');
            const slider45 = document.getElementById('slider4-5');
            const value45 = document.getElementById('value4-5');
            const slider67 = document.getElementById('slider6-7');
            const value67 = document.getElementById('value6-7');

            let grid = [];
            let isRunning = false;
            let interactionMode = 'none'; // 'none', 'bleach'
            let intervalId;
            let generation = 0;
            let oldestCell = null; // Tracks the coordinates of the oldest cell
            let lastStepSpawns = 0;
            let lastStepDeaths = 0;
            let occupiedHistory = [];
            let bleachEvents = [];
            let droughtEvents = [];
            let isDroughtActive = false;

            // --- Grid Initialization and Rendering ---
            function createGrid() {
                gridContainer.innerHTML = '';
                grid = new Array(GRID_SIZE).fill(null).map(() => new Array(GRID_SIZE).fill(null).map(() => ({ isAlive: false, age: 0, bleach: 0 })));
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        gridContainer.appendChild(cell);
                    }
                }
            }

            function getColorFromAge(age) {
                if (age <= 10) {
                    const t = age / 10;
                    const r = 255 - (127 * t);
                    const g = 255 - (127 * t);
                    const b = 255 - (127 * t);
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    const t = Math.min((age - 10) / 10, 1);
                    const r = 128 + (127 * t);
                    const g = 128 - (128 * t);
                    const b = 128 - (128 * t);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }

            function lerpColor(color1, color2, t) {
                const c1 = color1.match(/\d+/g).map(Number);
                const c2 = color2.match(/\d+/g).map(Number);
                const r = c1[0] + (c2[0] - c1[0]) * t;
                const g = c1[1] + (c2[1] - c1[1]) * t;
                const b = c1[2] + (c2[2] - c1[2]) * t;
                return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
            }

            function renderGrid() {
                const cells = gridContainer.querySelectorAll('.cell');
                cells.forEach(cellElement => {
                    const row = parseInt(cellElement.dataset.row);
                    const col = parseInt(cellElement.dataset.col);
                    const cellState = grid[row][col];
                    cellElement.classList.remove('oldest-cell');

                    if (cellState.isAlive) {
                        cellElement.classList.add('alive');
                        let cellColor = getColorFromAge(cellState.age);
                        if (cellState.bleach > 0) {
                            cellColor = lerpColor(cellColor, `rgb(200, 255, 255)`, cellState.bleach / 100);
                        }
                        cellElement.style.backgroundColor = cellColor;
                    } else {
                        cellElement.classList.remove('alive');
                        if (cellState.bleach > 0) {
                             cellElement.style.backgroundColor = lerpColor(`rgb(45, 55, 72)`, `rgb(200, 255, 255)`, cellState.bleach / 100);
                        } else if (isDroughtActive) {
                             cellElement.style.backgroundColor = '#624623';
                        }
                        else {
                             cellElement.style.backgroundColor = '';
                        }
                    }

                    if (oldestCell && oldestCell.r === row && oldestCell.c === col) {
                        cellElement.classList.add('oldest-cell');
                    }
                });
            }

            // --- Simulation Logic ---
            function countLiveNeighbors(row, col) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const neighborRow = row + i;
                        const neighborCol = col + j;
                        if (neighborRow >= 0 && neighborRow < GRID_SIZE && neighborCol >= 0 && neighborCol < GRID_SIZE) {
                            if (grid[neighborRow][neighborCol].isAlive) {
                                count++;
                            }
                        }
                    }
                }
                return count;
            }

            function findEmptyNeighbors(row, col) {
                const emptyNeighbors = [];
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const neighborRow = row + i;
                        const neighborCol = col + j;
                        if (neighborRow >= 0 && neighborRow < GRID_SIZE && neighborCol >= 0 && neighborCol < GRID_SIZE) {
                            if (!grid[neighborRow][neighborCol].isAlive) {
                                emptyNeighbors.push({ r: neighborRow, c: neighborCol });
                            }
                        }
                    }
                }
                return emptyNeighbors;
            }

            function updateGrid() {
                const nextGrid = JSON.parse(JSON.stringify(grid));
                lastStepSpawns = 0;
                lastStepDeaths = 0;
                let maxAge = -1;
                oldestCell = null;

                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cellState = grid[r][c];

                        // Handle bleach effect first
                        if (cellState.bleach > 0) {
                            const deathChance = cellState.bleach / 100;
                            if (Math.random() < deathChance) {
                                nextGrid[r][c].isAlive = false;
                                nextGrid[r][c].age = 0;
                                lastStepDeaths++;
                            }
                            nextGrid[r][c].bleach = Math.max(0, cellState.bleach - BLEACH_FADE_RATE);
                        }

                        if (cellState.isAlive) {
                            // Age-based death chance
                            if (cellState.age > 10) {
                                const ageDeathChance = Math.min(0.20 + (cellState.age - 10) * 0.05, 0.90);
                                if (Math.random() < ageDeathChance) {
                                    nextGrid[r][c].isAlive = false;
                                    nextGrid[r][c].age = 0;
                                    lastStepDeaths++;
                                    continue;
                                }
                            }
                            
                            if (cellState.age > maxAge) {
                                maxAge = cellState.age;
                                oldestCell = { r, c };
                            }

                            const liveNeighbors = countLiveNeighbors(r, c);
                            const emptyNeighbors = findEmptyNeighbors(r, c);

                            if (emptyNeighbors.length > 0) {
                                let spawnChance = 0;
                                if (isDroughtActive) {
                                    if (liveNeighbors >= 6 && liveNeighbors <= 7) {
                                        spawnChance = DROUGHT_HIGH_GROWTH / 100;
                                    } else {
                                        spawnChance = DROUGHT_LOW_GROWTH / 100;
                                    }
                                } else {
                                    if (liveNeighbors === 0) {
                                        spawnChance = parseInt(slider0.value) / 100;
                                    } else if (liveNeighbors >= 1 && liveNeighbors <= 3) {
                                        spawnChance = parseInt(slider13.value) / 100;
                                    } else if (liveNeighbors >= 4 && liveNeighbors <= 5) {
                                        spawnChance = parseInt(slider45.value) / 100;
                                    } else if (liveNeighbors >= 6 && liveNeighbors <= 7) {
                                        spawnChance = parseInt(slider67.value) / 100;
                                    }
                                }

                                if (Math.random() < spawnChance) {
                                    const randomNeighbor = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                                    if (!nextGrid[randomNeighbor.r][randomNeighbor.c].isAlive) {
                                        nextGrid[randomNeighbor.r][randomNeighbor.c].isAlive = true;
                                        nextGrid[randomNeighbor.r][randomNeighbor.c].age = 0;
                                        lastStepSpawns++;
                                    }
                                }
                            }
                            nextGrid[r][c].age++;
                        }
                    }
                }
                grid = nextGrid;
                generation++;
                generationCountSpan.textContent = generation;
                
                const liveCellCount = grid.flat().filter(cell => cell.isAlive).length;
                occupiedHistory.push(liveCellCount / (GRID_SIZE * GRID_SIZE) * 100);

                if (isDroughtActive) {
                    if (generation >= droughtEvents[droughtEvents.length - 1].end) {
                        isDroughtActive = false;
                        resetDroughtSliders();
                        renderGrid(); // Redraw grid when drought ends
                    }
                }

                renderGrid();
            }

            function drawSparkline() {
                const canvasWidth = occupiedSparklineCanvas.width;
                const canvasHeight = occupiedSparklineCanvas.height;

                sparklineCtx.clearRect(0, 0, canvasWidth, canvasHeight);

                if (occupiedHistory.length < 2) {
                    return;
                }

                const maxOccupancy = Math.max(...occupiedHistory);
                const minOccupancy = Math.min(...occupiedHistory);
                const occupancyRange = maxOccupancy - minOccupancy;
                
                const getX = (index) => (index / (occupiedHistory.length - 1)) * canvasWidth;
                const getY = (value) => {
                    if (occupancyRange === 0) {
                        return canvasHeight / 2;
                    }
                    return canvasHeight - ((value - minOccupancy) / occupancyRange) * canvasHeight;
                };

                sparklineCtx.lineWidth = 2;

                for (let i = 0; i < occupiedHistory.length - 1; i++) {
                    let startColor = '#4c51bf';
                    let endColor = '#4c51bf';

                    // Check for drought highlights
                    droughtEvents.forEach(event => {
                        if (i >= event.start && i < event.end) {
                            startColor = '#DD6B20'; // Orange
                        }
                        if (i + 1 >= event.start && i + 1 < event.end) {
                            endColor = '#DD6B20';
                        }
                    });

                    // Check for bleach highlights
                    bleachEvents.forEach(event => {
                        if (i >= event.start && i < event.end) {
                             startColor = '#0BC5EA'; // Cyan
                        }
                        if (i + 1 >= event.start && i + 1 < event.end) {
                            endColor = '#0BC5EA';
                        }
                    });

                    const gradient = sparklineCtx.createLinearGradient(getX(i), 0, getX(i+1), 0);
                    gradient.addColorStop(0, startColor);
                    gradient.addColorStop(1, endColor);
                    sparklineCtx.strokeStyle = gradient;

                    sparklineCtx.beginPath();
                    sparklineCtx.moveTo(getX(i), getY(occupiedHistory[i]));
                    sparklineCtx.lineTo(getX(i + 1), getY(occupiedHistory[i + 1]));
                    sparklineCtx.stroke();
                }
            }

            function updateDashboard() {
                dashboardTitle.textContent = `Simulation Stats: Generation ${generation}`;

                let mouldCellAges = [];
                let mouldCellCount = 0;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = grid[r][c];
                        if (cell.isAlive) {
                            mouldCellAges.push(cell.age);
                            mouldCellCount++;
                        }
                    }
                }
                const liveCellCount = mouldCellCount;

                // 1. Occupancy Meter
                const occupiedPercentage = (liveCellCount / (GRID_SIZE * GRID_SIZE) * 100).toFixed(1);
                occupiedBar.style.width = `${occupiedPercentage}%`;
                if (occupiedPercentage <= 50) {
                    occupiedBar.style.backgroundColor = '#10b981'; // green-500
                } else if (occupiedPercentage <= 80) {
                    occupiedBar.style.backgroundColor = '#facc15'; // yellow-400
                } else {
                    occupiedBar.style.backgroundColor = '#ef4444'; // red-500
                }
                occupiedPercentageSpan.textContent = `${occupiedPercentage}%`;

                drawSparkline();

                // 2. Bar Chart Data
                const agesSorted = mouldCellAges.slice().sort((a, b) => a - b);
                const maxAge = agesSorted.length > 0 ? agesSorted[agesSorted.length - 1] : 0;
                const minAge = agesSorted.length > 0 ? agesSorted[0] : 0;
                
                const ageQuintiles = [0, 0, 0, 0, 0];
                const ageRange = maxAge - minAge;

                if (mouldCellCount > 0) {
                    agesSorted.forEach(age => {
                        let quintileIndex = 0;
                        if (ageRange > 0) {
                             quintileIndex = Math.min(Math.floor(((age - minAge) / ageRange) * 5), 4);
                        }
                        ageQuintiles[quintileIndex]++;
                    });
                }
                
                const quintileLabels = [];
                if (ageRange > 0) {
                    const step = ageRange / 5;
                    for (let i = 0; i < 5; i++) {
                        const start = Math.floor(minAge + (step * i));
                        const end = Math.floor(minAge + (step * (i + 1)));
                        quintileLabels.push(`${start}-${end}`);
                    }
                } else {
                     quintileLabels.push(`${minAge}-${maxAge}`, '', '', '', '');
                }

                const chartData = [
                    { value: lastStepSpawns, label: 'Spawns' },
                    { value: ageQuintiles[0], label: quintileLabels[0] },
                    { value: ageQuintiles[1], label: quintileLabels[1] },
                    { value: ageQuintiles[2], label: quintileLabels[2] },
                    { value: ageQuintiles[3], label: quintileLabels[3] },
                    { value: ageQuintiles[4], label: quintileLabels[4] },
                    { value: lastStepDeaths, label: 'Deaths' }
                ];
                
                const maxChartValue = Math.max(...chartData.map(d => d.value));

                barChartContainer.innerHTML = ''; // Clear old bars
                chartData.forEach(data => {
                    const col = document.createElement('div');
                    col.classList.add('bar-chart-col');
                    const barHeight = maxChartValue > 0 ? (data.value / maxChartValue) * 100 : 0;
                    col.innerHTML = `
                        <div class="bar-chart-bar" style="height: ${barHeight}%;">
                            <span class="bar-chart-value">${data.value}</span>
                        </div>
                        <span class="bar-chart-label">${data.label}</span>
                    `;
                    barChartContainer.appendChild(col);
                });

                // 3. Additional Stats
                const totalAge = mouldCellAges.reduce((sum, age) => sum + age, 0);
                const averageAge = mouldCellCount > 0 ? (totalAge / mouldCellCount).toFixed(1) : 0;
                const growthRate = lastStepSpawns - lastStepDeaths;
                
                averageAgeSpan.textContent = averageAge;
                oldestAgeSpan.textContent = maxAge;
                growthRateSpan.textContent = `${growthRate} cells`;
                
                dashboard.style.display = 'block';
            }

            // --- Game Controls ---
            function startSimulation() {
                if (!isRunning) {
                    isRunning = true;
                    startButton.textContent = 'Pause';
                    dashboard.style.display = 'none';
                    intervalId = setInterval(updateGrid, 100);
                } else {
                    pauseSimulation();
                }
            }

            function pauseSimulation() {
                isRunning = false;
                startButton.textContent = 'Start';
                clearInterval(intervalId);
                if (generation > 0) {
                    updateDashboard();
                }
            }
            
            function resetDroughtSliders() {
                 slider0.value = 25;
                 value0.textContent = '25%';
                 slider13.value = 50;
                 value13.textContent = '50%';
                 slider45.value = 25;
                 value45.textContent = '25%';
                 slider67.value = 5;
                 value67.textContent = '5%';
            }

            function resetSimulation() {
                pauseSimulation();
                createGrid();
                oldestCell = null;
                generation = 0;
                lastStepSpawns = 0;
                lastStepDeaths = 0;
                occupiedHistory = [];
                bleachEvents = [];
                droughtEvents = [];
                isDroughtActive = false;
                generationCountSpan.textContent = generation;
                
                dashboard.style.display = 'none';
                
                const randomRow = Math.floor(Math.random() * GRID_SIZE);
                const randomCol = Math.floor(Math.random() * GRID_SIZE);
                grid[randomRow][randomCol].isAlive = true;
                grid[randomRow][randomCol].age = 0;
                renderGrid();
            }
            
            // --- Interaction Modes ---
            function toggleMode(mode) {
                if (interactionMode === mode) {
                    interactionMode = 'none';
                    gridContainer.style.cursor = 'pointer';
                    bleachButton.textContent = 'Bleach Splash';
                } else {
                    interactionMode = mode;
                    pauseSimulation();
                    gridContainer.style.cursor = 'crosshair';
                    if (mode === 'bleach') {
                        bleachButton.textContent = 'Cancel Bleach';
                    }
                }
            }
            
            function handleGridClick(event) {
                const cell = event.target;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                if (!isNaN(row) && !isNaN(col)) {
                    if (interactionMode === 'bleach') {
                        applyBleach(row, col);
                        toggleMode('none');
                        renderGrid();
                        bleachEvents.push({ start: generation, end: generation + Math.ceil(BLEACH_INITIAL_VALUE / BLEACH_FADE_RATE) });
                    }
                }
            }
            
            function applyBleach(clickRow, clickCol) {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const distance = Math.sqrt(Math.pow(r - clickRow, 2) + Math.pow(c - clickCol, 2));
                        const bleachConcentration = Math.max(0, BLEACH_INITIAL_VALUE - distance * BLEACH_DECAY_RATE);
                        grid[r][c].bleach = bleachConcentration;
                    }
                }
            }
            
            function toggleDrought() {
                if (isDroughtActive) {
                    isDroughtActive = false;
                    resetDroughtSliders();
                    renderGrid(); // Redraw grid when drought ends
                } else {
                    isDroughtActive = true;
                    droughtEvents.push({ start: generation, end: generation + DROUGHT_DURATION });
                    
                    slider0.value = DROUGHT_LOW_GROWTH;
                    value0.textContent = `${DROUGHT_LOW_GROWTH}%`;
                    slider13.value = DROUGHT_LOW_GROWTH;
                    value13.textContent = `${DROUGHT_LOW_GROWTH}%`;
                    slider45.value = DROUGHT_LOW_GROWTH;
                    value45.textContent = `${DROUGHT_LOW_GROWTH}%`;
                    slider67.value = DROUGHT_HIGH_GROWTH;
                    value67.textContent = `${DROUGHT_HIGH_GROWTH}%`;
                    
                    renderGrid();
                }
            }

            function takeScreenshot() {
                const tempContainer = document.createElement('div');
                tempContainer.style.width = '1200px';
                tempContainer.style.height = '600px';
                tempContainer.style.display = 'flex';
                tempContainer.style.backgroundColor = '#1a202c';
                tempContainer.style.padding = '20px';
                tempContainer.style.boxSizing = 'border-box';
                tempContainer.style.color = '#e2e8f0';
                
                const gridClone = gridContainer.cloneNode(true);
                gridClone.style.flex = '1';
                gridClone.style.maxWidth = '550px';
                gridClone.style.paddingTop = '100%';
                gridClone.style.marginRight = '20px';
                
                const statsContainer = document.createElement('div');
                statsContainer.style.flex = '1';
                statsContainer.style.display = 'flex';
                statsContainer.style.flexDirection = 'column';
                statsContainer.style.maxWidth = '550px';
                
                const sliderValues = document.createElement('div');
                sliderValues.innerHTML = `<h4 style="font-weight: bold; font-size: 1.25rem;">Chance of growth per step</h4><p style="margin-top: 10px;">0 Neighbors: ${slider0.value}% | 1-3 Neighbors: ${slider13.value}% | 4-5 Neighbors: ${slider45.value}% | 6-7 Neighbors: ${slider67.value}%</p>`;
                
                const dashboardClone = dashboard.cloneNode(true);
                dashboardClone.style.display = 'block';
                
                statsContainer.appendChild(sliderValues);
                statsContainer.appendChild(dashboardClone);
                
                tempContainer.appendChild(gridClone);
                tempContainer.appendChild(statsContainer);
                
                document.body.appendChild(tempContainer);
                
                // Manually re-draw sparkline on cloned canvas
                const clonedSparkline = dashboardClone.querySelector('#occupiedSparkline');
                const clonedSparklineCtx = clonedSparkline.getContext('2d');
                clonedSparklineCtx.clearRect(0, 0, clonedSparkline.width, clonedSparkline.height);
                
                const occupiedHistoryCopy = occupiedHistory.slice();
                if (occupiedHistoryCopy.length > 1) {
                    const canvasWidth = clonedSparkline.width;
                    const canvasHeight = clonedSparkline.height;
                    const maxOccupancy = Math.max(...occupiedHistoryCopy);
                    const minOccupancy = Math.min(...occupiedHistoryCopy);
                    const occupancyRange = maxOccupancy - minOccupancy;

                    const getX = (index) => (index / (occupiedHistoryCopy.length - 1)) * canvasWidth;
                    const getY = (value) => {
                        if (occupancyRange === 0) {
                            return canvasHeight / 2;
                        }
                        return canvasHeight - ((value - minOccupancy) / occupancyRange) * canvasHeight;
                    };
                    
                    clonedSparklineCtx.lineWidth = 2;
                    clonedSparklineCtx.beginPath();
                    
                    for (let i = 0; i < occupiedHistoryCopy.length - 1; i++) {
                        let startColor = '#4c51bf';
                        let endColor = '#4c51bf';

                        droughtEvents.forEach(event => {
                            if (i >= event.start && i < event.end) {
                                startColor = '#DD6B20';
                            }
                            if (i + 1 >= event.start && i + 1 < event.end) {
                                endColor = '#DD6B20';
                            }
                        });

                        bleachEvents.forEach(event => {
                            if (i >= event.start && i < event.end) {
                                 startColor = '#0BC5EA';
                            }
                            if (i + 1 >= event.start && i + 1 < event.end) {
                                endColor = '#0BC5EA';
                            }
                        });

                        const gradient = clonedSparklineCtx.createLinearGradient(getX(i), 0, getX(i+1), 0);
                        gradient.addColorStop(0, startColor);
                        gradient.addColorStop(1, endColor);
                        clonedSparklineCtx.strokeStyle = gradient;

                        clonedSparklineCtx.beginPath();
                        clonedSparklineCtx.moveTo(getX(i), getY(occupiedHistoryCopy[i]));
                        clonedSparklineCtx.lineTo(getX(i + 1), getY(occupiedHistoryCopy[i + 1]));
                        clonedSparklineCtx.stroke();
                    }
                }
                
                html2canvas(tempContainer, {
                    backgroundColor: '#1a202c',
                    scale: 2
                }).then(canvas => {
                    const image = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
                    const link = document.createElement('a');
                    link.download = 'mould-simulation.png';
                    link.href = image;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    document.body.removeChild(tempContainer);
                });
            }

            // Initial setup
            createGrid();
            resetSimulation();
            setupSliderListeners();

            // Event Listeners
            startButton.addEventListener('click', startSimulation);
            resetButton.addEventListener('click', resetSimulation);
            bleachButton.addEventListener('click', () => toggleMode('bleach'));
            droughtButton.addEventListener('click', toggleDrought);
            gridContainer.addEventListener('click', handleGridClick);
            screenshotButton.addEventListener('click', takeScreenshot);
            
            helpButton.addEventListener('click', () => {
                helpModal.style.display = 'flex';
            });
            closeModal.addEventListener('click', () => {
                helpModal.style.display = 'none';
            });

            function setupSliderListeners() {
                slider0.addEventListener('input', () => {
                    value0.textContent = `${slider0.value}%`;
                });
                slider13.addEventListener('input', () => {
                    value13.textContent = `${slider13.value}%`;
                });
                slider45.addEventListener('input', () => {
                    value45.textContent = `${slider45.value}%`;
                });
                slider67.addEventListener('input', () => {
                    value67.textContent = `${slider67.value}%`;
                });
            }
        });
    </script>
</body>
</html>
